[
  {
    "sequence": 10,
    "id": "WS-CODEX-010",
    "phase": "Phase 0 \u2013 Runtime foundation",
    "title": "Replace stub LLM runtime with real WebLLM engine",
    "summary": "Swap out the stubbed LLM engine for a real WebLLM-based engine and expose a streaming API that the AIProvider can use.",
    "instructions": "You are enhancing The Workshop (kids-first AI creative studio). The current LLM runtime in app/src/runtime/llm/webllm_loader.ts is a stub that just splits the prompt and streams tokens back.\n\nGoal for this task:\nReplace the stub engine with a real WebLLM engine that can run a small local model in the browser and expose a streaming generate API.\n\nDo the following steps in order:\n\n1) Install WebLLM dependency\n   - Ensure @mlc-ai/web-llm is installed in the project.\n   - If package.json does not include it, add it and assume npm install will be run outside this task.\n\n2) Define a model catalog\n   - Create app/src/runtime/llm/model_manifest.ts (or update if it exists).\n   - Export a MODEL_CATALOG object listing at least:\n     - phi3_mini: default small model id (for example Phi-3-mini-4k-instruct-q4)\n     - qwen2_15b: backup model id (Qwen2.5-1.5B-instruct-q4 or similar)\n     - tiny_llama: tiny fallback model id (TinyLlama-1.1B-chat-q4 or similar)\n   - These ids should match plausible WebLLM model identifiers but the exact assets will be configured later.\n\n3) Implement WebLLM engine loader\n   - In app/src/runtime/llm/webllm_loader.ts:\n     - Remove or disable the existing createStubEngine implementation.\n     - Import CreateWebWorkerMLCEngine (or the appropriate WebLLM API) from @mlc-ai/web-llm.\n     - Implement a getEngine() function that lazily creates and caches a single WebLLM engine instance using a Web Worker.\n     - Configure the engine with the default model from MODEL_CATALOG (phi3_mini).\n\n4) Implement a streaming generate API\n   - Export an async generator function generateStream(prompt: string): AsyncGenerator<{ token: string; done: boolean }> from webllm_loader.ts.\n   - It should:\n     - Ensure the engine is initialized via getEngine().\n     - Send the user prompt using a simple chatCompletion or equivalent API.\n     - Yield chunks of text as { token, done: false } as they arrive.\n     - Yield a final { token: \"\", done: true } when the stream is complete.\n   - Add simple guards for maximum tokens and a reasonable timeout to support low-end devices.\n\n5) Add basic error handling\n   - If the engine fails to initialize or a generation error occurs:\n     - Log a concise error to the console.\n     - Throw a controlled error or yield a small apology message so the UI can handle it gracefully.\n\nDo not modify any station UI or project logic in this task. Focus only on the LLM runtime and its public streaming interface.",
    "acceptance_criteria": [
      "webllm_loader.ts no longer uses the string-splitting stub implementation.",
      "A MODEL_CATALOG exists listing at least phi3_mini, qwen2_15b, and tiny_llama identifiers.",
      "getEngine() initializes a single WebLLM engine lazily and caches it.",
      "generateStream(prompt) is implemented as an async generator yielding { token, done } chunks.",
      "Errors in engine initialization or generation are handled gracefully and documented with comments."
    ]
  },
  {
    "sequence": 11,
    "id": "WS-CODEX-011",
    "phase": "Phase 0 \u2013 Runtime foundation",
    "title": "Wire AIProvider to use WebLLM generateStream and station-aware calls",
    "summary": "Connect the React AIProvider to the new WebLLM runtime and provide a simple station-aware callStationModel API for the rest of the app.",
    "instructions": "You are continuing work on The Workshop runtime. The WebLLM engine loader (webllm_loader.ts) now exposes a generateStream(prompt) async generator.\n\nGoal for this task:\nWire the AIProvider (React context) to use generateStream and expose a small, station-aware API for making AI calls.\n\nPerform the following steps:\n\n1) Locate or create AIProvider\n   - Find the file that defines the AI context/provider (for example app/src/runtime/ai/AIProvider.tsx or similar).\n   - If it does not exist, create a minimal AIProvider in a sensible location under app/src/runtime/ai/.\n   - The provider should:\n     - Hold any needed AI-related state (loading flags, errors, last response).\n     - Expose a context value with AI call functions.\n\n2) Add station-aware call API\n   - Design and implement a function with a signature similar to:\n     - callStationModel(stationKey: string, payload: { systemPrompt: string; userPrompt: string }): AsyncGenerator<{ token: string; done: boolean }>\n   - stationKey is a string like \"idea\", \"build\", \"test\", etc.\n   - payload.systemPrompt and payload.userPrompt will be composed by higher-level station code.\n\n3) Compose prompts inside AIProvider\n   - Inside callStationModel:\n     - Build a full prompt string that includes:\n       - Station role and key.\n       - Safety reminders from the Safety Contract (docs/SAFETY_CONTRACT.md).\n       - Creativity boundary reminders (docs/CREATIVITY_BOUNDARY_SPEC.md).\n       - The station-specific system content from payload.systemPrompt.\n       - The user-specific content from payload.userPrompt.\n     - Keep the composition simple and clearly commented so future changes are easy.\n\n4) Delegate to generateStream\n   - Use generateStream(fullPrompt) from webllm_loader.ts to produce the output tokens.\n   - Expose this as an async generator so station components can stream results into their UIs.\n\n5) Export a React hook\n   - Add a useAI() hook that returns the context value, including callStationModel.\n   - Ensure null/undefined context is guarded with a clear error message if used outside the provider.\n\n6) Wrap the app with AIProvider\n   - Ensure the top-level App component (or router root) is wrapped with AIProvider so all stations can access useAI().\n\nDo not design the station prompts themselves here; that will be handled in separate tasks. Focus on wiring and context structure.",
    "acceptance_criteria": [
      "An AIProvider component exists and is used to wrap the app.",
      "A useAI() hook is available and returns a context value.",
      "callStationModel(stationKey, payload) is implemented and composes a full prompt including safety and boundary reminders.",
      "callStationModel delegates to generateStream from webllm_loader.ts and returns a streaming async generator.",
      "All new code is commented to explain how safety and creativity boundaries are injected."
    ]
  },
  {
    "sequence": 12,
    "id": "WS-CODEX-012",
    "phase": "Phase 1 \u2013 Core framework",
    "title": "Define Project domain model and local storage adapter",
    "summary": "Create a canonical Project type, station slices, and a local-storage backed adapter for loading and saving projects.",
    "instructions": "You are now working on The Workshop's project model and persistence.\n\nGoal for this task:\nDefine the Project domain model, including an Idea Station slice, and implement a local storage adapter for loading and saving projects.\n\nPerform these steps:\n\n1) Define Project types\n   - Create or update app/src/domain/project.ts.\n   - Define a StationIdea type that includes:\n     - title: string\n     - mission: string\n     - goal: string\n     - starterSteps: string[] (1 to 3 entries)\n   - Define a Project type that includes at minimum:\n     - id: string\n     - name: string\n     - createdAt: string (ISO timestamp)\n     - updatedAt: string (ISO timestamp)\n     - idea?: StationIdea\n     - (leave placeholders or TODO comments for build, test, memory, reflect, share, replay slices)\n\n   - Enforce reasonable max lengths in comments based on docs/CREATIVITY_BOUNDARY_SPEC.md.\n\n2) Implement a local storage adapter\n   - Create app/src/runtime/storage/local_project_store.ts.\n   - Implement functions:\n     - loadAllProjects(): Promise<Project[]>\n     - loadProject(id: string): Promise<Project | null>\n     - saveProject(project: Project): Promise<void>\n   - Use window.localStorage with a single key (for example \"workshop.projects\") containing a JSON array of Project objects.\n   - Ensure defensive parsing: handle missing or malformed data by returning an empty array or null.\n\n3) Enforce basic size limits\n   - In saveProject, enforce a rough cap on:\n     - Number of projects (for example 50 for v1).\n     - Size of text fields (truncate if needed, consistent with Creativity Boundary spec).\n   - Document these limits in comments with a reference to docs/CREATIVITY_BOUNDARY_SPEC.md.\n\n4) Add simple ID generation helper\n   - If no standard exists yet, create a small helper (for example in domain or storage) to generate project IDs (timestamp + random suffix is fine for v1).\n\nDo not connect this adapter to React state or UI yet; that will be handled in the next tasks.",
    "acceptance_criteria": [
      "app/src/domain/project.ts defines a StationIdea type and a Project type with at least id, name, createdAt, updatedAt, and optional idea.",
      "local_project_store.ts exists and exports loadAllProjects, loadProject, and saveProject using localStorage.",
      "The storage adapter handles missing or malformed data defensively.",
      "Basic limits on project count and field lengths are enforced or clearly documented.",
      "A simple ID generation helper exists or is documented for creating new projects."
    ]
  },
  {
    "sequence": 13,
    "id": "WS-CODEX-013",
    "phase": "Phase 1 \u2013 Core framework",
    "title": "Implement projectStore and connect it to local storage",
    "summary": "Replace the placeholder projectStore with a typed store that manages Project state, persists to local storage, and supports selection and subscription.",
    "instructions": "You are building the core projectStore for The Workshop.\n\nGoal for this task:\nImplement a typed projectStore that manages all Project entities in memory, persists them via the local storage adapter, and exposes a subscription API for React components.\n\nPerform these steps:\n\n1) Locate or create projectStore\n   - Find the existing projectStore implementation (likely under app/src/runtime/store or similar).\n   - If it is only a simple event bus placeholder, plan to replace it with a stronger typed store.\n   - If no file exists, create app/src/runtime/store/projectStore.ts.\n\n2) Define in-memory state\n   - Maintain:\n     - A map of id -> Project.\n     - An optional selectedProjectId string.\n   - Initialize state by calling loadAllProjects() from local_project_store.ts.\n\n3) Public API shape\n   - Implement and export functions or an object with methods:\n     - getProjects(): Project[]\n     - getProject(id: string): Project | undefined\n     - getSelectedProject(): Project | undefined\n     - createProject(name: string): Project\n     - updateProject(id: string, patch: Partial<Project>): Project | undefined\n     - selectProject(id: string | null): void\n     - subscribe(listener: () => void): () => void  // returns unsubscribe\n\n4) Persistence behavior\n   - Whenever createProject or updateProject changes the state:\n     - Update the in-memory map and updatedAt timestamp.\n     - Call saveProject(project) for the affected project.\n     - Optionally also refresh the full list saved in local storage if needed.\n   - Ensure operations are resilient to storage errors (log, but do not crash the app).\n\n5) Respect creativity boundaries\n   - Before persisting, enforce the constraints described in docs/CREATIVITY_BOUNDARY_SPEC.md for the Idea slice (length of title, mission, goal, and number of starter steps).\n   - Truncate or clamp as needed and document this with comments.\n\n6) Integration notes\n   - Do not wire projectStore directly into React context in this task, but make sure it is written in a way that a React hook can easily subscribe to it in a later task.\n\nFocus on correctness, traceability, and clear typing.",
    "acceptance_criteria": [
      "projectStore exists in app/src/runtime/store/projectStore.ts or similar and manages an in-memory map of projects plus selectedProjectId.",
      "projectStore API provides getProjects, getProject, getSelectedProject, createProject, updateProject, selectProject, and subscribe.",
      "local_project_store.loadAllProjects is used at initialization to populate state.",
      "saveProject is called whenever a project is created or updated.",
      "Idea slice fields respect the limits defined in the Creativity Boundary spec, with truncation or clamping where appropriate."
    ]
  },
  {
    "sequence": 14,
    "id": "WS-CODEX-014",
    "phase": "Phase 1 \u2013 Core framework",
    "title": "Expose projectStore via React hook and build basic project list UI",
    "summary": "Create a React hook that bridges projectStore into components and build a simple project selection screen.",
    "instructions": "You are now tying the projectStore into the React app shell.\n\nGoal for this task:\nProvide a React hook for accessing projectStore and create a simple project list UI where users can create and select projects.\n\nPerform these steps:\n\n1) Create a React hook for projectStore\n   - In app/src/runtime/hooks or a similar location, create useProjects.ts.\n   - The hook should:\n     - Subscribe to projectStore on mount.\n     - Expose:\n       - projects: Project[]\n       - selectedProject: Project | undefined\n       - createProject(name: string)\n       - selectProject(id: string | null)\n       - updateProject(id: string, patch: Partial<Project>)\n     - Clean up subscription on unmount.\n\n2) Implement a ProjectSelectionPage\n   - In app/src/pages or equivalent, create ProjectSelectionPage.tsx.\n   - The page should:\n     - Use useProjects() to retrieve the list and selection APIs.\n     - Show a list of existing projects with name and updatedAt.\n     - Provide a simple \"New Project\" form with a name field and button.\n     - Select a project when clicked, and navigate to the main Workshop view for that project (router integration may be minimal for now).\n\n3) Wire the page into routing\n   - Update the router configuration so that:\n     - There is a route like \"/projects\" that shows ProjectSelectionPage.\n     - Optionally treat it as the default / root route for now.\n\n4) Visual style\n   - Use the existing design system (Tailwind/Radix/Shadcn if available) to keep styling simple and clean.\n   - Ensure the layout and text are readable for kids, with clear buttons and labels.\n\nDo not implement station-specific UI here. Focus on project selection and the hook layer.",
    "acceptance_criteria": [
      "A useProjects hook exists and exposes projects, selectedProject, and basic CRUD/select operations.",
      "ProjectSelectionPage.tsx shows a list of projects and allows creating a new one.",
      "Selecting a project updates projectStore and routes to the main Workshop view (or at least updates selection in state).",
      "The hook correctly subscribes to and unsubscribes from projectStore changes."
    ]
  },
  {
    "sequence": 15,
    "id": "WS-CODEX-015",
    "phase": "Phase 2 \u2013 Idea Station",
    "title": "Implement Idea Station (Design Dock) UI and AI integration",
    "summary": "Build the Idea Station screen with title/mission/goal/starter steps, wire it to projectStore and AIProvider, and respect creativity boundaries.",
    "instructions": "You are implementing the first real Station: Idea Station (Design Dock).\n\nGoal for this task:\nBuild a usable Idea Station UI that lets the child define an idea title, mission, goal, and up to three starter steps, and use AI to help refine or generate those fields.\n\nPerform these steps:\n\n1) Create IdeaStationPage component\n   - In app/src/stations/idea/ or similar, create IdeaStationPage.tsx.\n   - The component should:\n     - Use useProjects() to get selectedProject and updateProject.\n     - Redirect or show a friendly message if no project is selected.\n     - Render input fields for:\n       - Idea title (single line)\n       - Mission (multi-line, short)\n       - Goal (multi-line, short)\n       - Starter steps (list of 1\u20133 short text inputs)\n     - Include character counters or hints to reinforce the field limits from the Creativity Boundary spec.\n\n2) Wire updates to projectStore\n   - On blur or on change (choose a simple pattern), call updateProject(project.id, { idea: updatedIdeaSlice }).\n   - Ensure the updatedAt timestamp is refreshed through projectStore logic.\n\n3) Integrate AI via useAI()\n   - Use the useAI() hook to access callStationModel(\"idea\", payload).\n   - Define a station-specific system prompt inline or in a small helper that:\n     - Describes the Idea Station role (Design Dock).\n     - References the learning loop: Ask, Reflect, Plan, Act, Review.\n     - Enforces safety rules and creativity boundaries at a high level.\n   - When the user clicks a button like \"Ask the Workshop for help\":\n     - Build a userPrompt from the current state (what the child has entered so far).\n     - Call callStationModel(\"idea\", { systemPrompt, userPrompt }).\n     - Stream the result into a temporary buffer, then parse it into:\n       - Possibly refined mission/goal.\n       - Up to three starter steps.\n     - Merge the AI result into the idea slice and save via projectStore.updateProject.\n\n   - Keep parsing logic simple: expect either structured JSON-like output from the model or a clearly delimited text format that you define in the system prompt.\n\n4) Enforce creativity boundaries\n   - Ensure that:\n     - Title length, mission length, goal length, and number of starter steps are clamped according to docs/CREATIVITY_BOUNDARY_SPEC.md.\n     - If the AI returns more than three steps or overly long text, truncate gracefully.\n\n5) Navigation integration\n   - Make sure the route for Idea Station (Design Dock) points to IdeaStationPage and is reachable from the project view or navigation bar.\n\nDo not implement other stations in this task. Focus on making Idea Station fully functional and child-friendly.",
    "acceptance_criteria": [
      "IdeaStationPage.tsx exists and is reachable via the existing router.",
      "The page uses useProjects() to load and update the selected project's idea slice.",
      "The UI has fields for title, mission, goal, and up to three starter steps with visible limits/hints.",
      "The AI button uses useAI().callStationModel('idea', \u2026) to refine or suggest mission and steps.",
      "AI outputs and manual inputs are clamped to the limits defined in the Creativity Boundary spec."
    ]
  },
  {
    "sequence": 16,
    "id": "WS-CODEX-016",
    "phase": "Phase 3 \u2013 Build Station",
    "title": "Implement Build Station (Assembly Bay) with single active step workflow",
    "summary": "Create the Build Station UI for working on one active step at a time, wired to projectStore and optionally AI hints.",
    "instructions": "You are now implementing the Build Station: Assembly Bay.\n\nGoal for this task:\nBuild a UI that lets the child choose a starter step from Idea Station, mark it as active, work on it, and mark it done, with optional AI hints.\n\nPerform these steps:\n\n1) Extend Project type with build slice\n   - In app/src/domain/project.ts, add a build slice to Project, for example:\n     - build?: {\n         steps: {\n           id: string;\n           text: string;\n           status: \"todo\" | \"active\" | \"done\";\n           notes?: string;\n         }[];\n         activeStepId?: string | null;\n       }\n   - Initial mapping can copy in starterSteps from idea as todo steps when Build Station is first opened.\n\n2) Create BuildStationPage component\n   - In app/src/stations/build/BuildStationPage.tsx:\n     - Use useProjects() to get the selected project and updateProject.\n     - If build slice is empty but idea.starterSteps exists, initialize build.steps from starterSteps.\n     - Render:\n       - A list of steps with their status.\n       - Ability to select one step as active (only one at a time).\n       - An area to enter notes for the active step.\n       - Buttons to mark the active step as done or move it back to todo.\n\n3) Optional AI hints for active step\n   - Use useAI() and callStationModel(\"build\", payload) to provide a button like \"Need ideas for this step?\".\n   - System prompt should frame the Build Station as:\n     - Helping with concrete suggestions for how to try a small piece of the step.\n     - Respecting safety and creativity boundaries.\n   - Stream results and display them as a short list of hints near the notes field.\n   - Do not auto-modify project steps based on AI; let the child copy ideas into notes manually.\n\n4) Persistence and limits\n   - All changes to build.steps and activeStepId should go through updateProject.\n   - Keep notes length within a sensible limit (see Creativity Boundary spec).\n   - Do not allow more than a modest number of steps (for example 10\u201312).\n\n5) Navigation\n   - Ensure Build Station route points to BuildStationPage and is easy to reach after Idea Station.\n\nFocus on making the Build Station feel like a calm, focused workspace for one step at a time.",
    "acceptance_criteria": [
      "Project type has a build slice with steps and optional activeStepId.",
      "BuildStationPage.tsx exists and can initialize steps from Idea Station starterSteps.",
      "Only one step can be active at a time; status transitions between todo, active, and done work correctly.",
      "AI hint button uses callStationModel('build', \u2026) and displays suggestions without auto-editing steps.",
      "All text fields and step counts respect boundaries from the Creativity Boundary spec."
    ]
  },
  {
    "sequence": 17,
    "id": "WS-CODEX-017",
    "phase": "Phase 3 \u2013 Test Station",
    "title": "Implement Test Station (Diagnostics Corridor) focused on clarity checks",
    "summary": "Create the Test Station UI as a focused, bounded chat around clarity and understanding, wired to projectStore and AIProvider.",
    "instructions": "You are implementing the Test Station: Diagnostics Corridor.\n\nGoal for this task:\nProvide a focused interface where the child can ask whether their work makes sense and get concrete, gentle feedback.\n\nPerform these steps:\n\n1) Extend Project type with test slice\n   - In app/src/domain/project.ts, add a test slice such as:\n     - test?: {\n         sessions: {\n           id: string;\n           createdAt: string;\n           question: string;\n           findings: string[];\n         }[];\n       }\n   - Keep this compact; it should be a short history of clarity checks, not full chats.\n\n2) Create TestStationPage component\n   - In app/src/stations/test/TestStationPage.tsx:\n     - Use useProjects() to get selectedProject and updateProject.\n     - Show a simple UI with:\n       - One text field: \"What are you wondering about?\"\n       - A button: \"Run a test\".\n       - A small area to stream the AI response and then summarize findings.\n     - After a test run, store a session entry in project.test.sessions with:\n       - question\n       - a short list of up to 5 findings extracted from the AI output.\n\n3) AI integration\n   - Use useAI().callStationModel(\"test\", payload) for the test.\n   - System prompt should frame the station as:\n     - Checking if the idea or step is clear to another person.\n     - Offering kind, concrete suggestions in simple language.\n     - Refusing unsafe content and staying within creativity boundaries.\n   - Encourage the model to respond with short bullet-like points that can be parsed into findings.\n\n4) Boundaries\n   - Enforce:\n     - One main question per session.\n     - A short interaction limit (for example, up to 5 findings only).\n   - Reflect these constraints in both UI and parsing logic.\n\n5) Display past sessions\n   - Below the main interface, show a simple list of previous test sessions with question and a one-line summary of findings.\n   - Keep the design minimal.\n\nDo not implement Memory/Reflect behavior here beyond saving test sessions. Focus on clarity testing as a bounded tool.",
    "acceptance_criteria": [
      "Project type has a compact test slice storing sessions with question and findings.",
      "TestStationPage.tsx exists and allows running a new test with a single question field and a button.",
      "AI responses are generated via callStationModel('test', \u2026) and parsed into up to 5 short findings.",
      "Each test run appends a session to project.test.sessions via updateProject.",
      "The UI shows a simple history of past test sessions in a kid-friendly way."
    ]
  },
  {
    "sequence": 18,
    "id": "WS-CODEX-018",
    "phase": "Phase 4 \u2013 Memory & Reflect",
    "title": "Implement Memory (Stellar Archive) and Reflect (Orbiter Bridge) Stations",
    "summary": "Build the Memory and Reflect stations to log wins, lessons, next-time intentions, and surface simple patterns.",
    "instructions": "You are implementing the Memory Station (Stellar Archive) and Reflect Station (Orbiter Bridge).\n\nGoal for this task:\nLet children capture small reflections about their work (wins, lessons, next-time) and see simple patterns across entries.\n\nPerform these steps:\n\n1) Extend Project type with memory and reflect slices\n   - In app/src/domain/project.ts, add:\n     - memory?: {\n         entries: {\n           id: string;\n           createdAt: string;\n           proudOf: string;\n           lesson: string;\n           nextTime: string;\n         }[];\n       }\n     - reflect?: {\n         snapshots: {\n           id: string;\n           createdAt: string;\n           tags: string[];\n           notes: string;\n         }[];\n       }\n   - Keep text lengths limited per docs/CREATIVITY_BOUNDARY_SPEC.md.\n\n2) MemoryStationPage (Stellar Archive)\n   - In app/src/stations/memory/MemoryStationPage.tsx:\n     - Use useProjects() to get selectedProject and updateProject.\n     - Provide three short fields:\n       - \"Something I\u2019m proud of\"\n       - \"Something I learned\"\n       - \"Something I might do next time\"\n     - A single button to save a reflection entry, which appends to memory.entries.\n     - Show a simple timeline list of previous entries with createdAt and proudOf/lesson summaries.\n\n3) ReflectStationPage (Orbiter Bridge)\n   - In app/src/stations/reflect/ReflectStationPage.tsx:\n     - Use useProjects() and data from memory, build, and test slices.\n     - Option 1 (non-AI v1): compute simple patterns locally, such as:\n       - How many entries mention similar words or tags.\n       - Frequency of visits to stations.\n     - Option 2 (AI-assisted): use useAI().callStationModel(\"reflect\", payload) to ask for gentle pattern summaries.\n     - UI should show:\n       - A short, plain language summary of patterns.\n       - Optional tag suggestions (for example: \"brave\", \"patient\", \"curious\").\n       - Tag selection and storing of a reflect.snapshots entry with tags and notes.\n\n4) Boundaries and tone\n   - Ensure text fields and tag counts respect the Creativity Boundary spec.\n   - Do not psychoanalyze or assign heavy labels; keep language about the work, not the child as a person.\n   - If using AI, system prompt must emphasize kindness, non-diagnostic language, and future-oriented suggestions.\n\n5) Integration\n   - Wire both stations into the router and main navigation.\n   - Ensure they behave sensibly if there are no entries yet (empty state messages).\n\nFocus on making these stations feel like a safe place to notice growth, not a grading system.",
    "acceptance_criteria": [
      "Project type has memory and reflect slices with compact, bounded structures.",
      "MemoryStationPage.tsx allows adding a reflection entry with proudOf, lesson, and nextTime fields and displays a simple timeline.",
      "ReflectStationPage.tsx surfaces simple patterns from memory/test/build data, either locally or with AI assistance, and can store tagged snapshots.",
      "Text lengths and tag counts are constrained to values consistent with the Creativity Boundary spec.",
      "The overall tone of both stations is supportive, non-diagnostic, and focused on effort and learning."
    ]
  },
  {
    "sequence": 19,
    "id": "WS-CODEX-019",
    "phase": "Phase 5 \u2013 Share Station",
    "title": "Implement Share Station (Broadcast Deck) and export template wiring",
    "summary": "Create the Share Station UI that assembles a one-page summary from project data using the export template design.",
    "instructions": "You are implementing the Share Station: Broadcast Deck.\n\nGoal for this task:\nLet the child turn their project journey into a single, safe, shareable artifact such as a one-page summary.\n\nPerform these steps:\n\n1) Extend Project type with share slice\n   - In app/src/domain/project.ts, add a share slice such as:\n     - share?: {\n         lastExportAt?: string;\n         lastFormat?: \"page\" | \"poster\";\n       }\n   - Keep this minimal for v1; the shared artifact can be generated on the fly from other slices.\n\n2) Create ShareStationPage component\n   - In app/src/stations/share/ShareStationPage.tsx:\n     - Use useProjects() to get the selected project.\n     - Provide controls to choose:\n       - Audience type (for example: family, teacher, friend).\n       - Export format (for example: simple one-page summary).\n     - Render a live preview of the export using the template design described in assets/manifest (template-share-page-a4).\n\n3) Compose export content\n   - Build the preview content from:\n     - Project name and idea mission/goal.\n     - Key steps from build.\n     - One or two test findings.\n     - One or two memory reflections.\n   - Keep text concise and safe; do not include personal contact information or sensitive details.\n   - Consider using AI via callStationModel(\"share\", payload) to help phrase the summary in kid-friendly language, but enforce strict length limits and safety constraints.\n\n4) Provide export actions\n   - For v1, support at least:\n     - Printing via the browser\u2019s print dialog (styling a print-friendly view).\n     - Export to a simple downloadable image or PDF if feasible, or document this as a later enhancement.\n   - Ensure there is a clear reminder to check with a trusted adult before sharing anything.\n\n5) Update share slice metadata\n   - When an export is generated or printed, update project.share.lastExportAt and lastFormat via updateProject.\n\nFocus on making Share Station feel like a celebration and storytelling moment, not a social media broadcast tool.",
    "acceptance_criteria": [
      "Project type has a minimal share slice to track lastExportAt and lastFormat.",
      "ShareStationPage.tsx exists and lets the user pick an audience and format, and shows a live preview.",
      "Preview content is composed from idea, build, test, and memory slices in concise, safe language.",
      "Print output is reasonably styled for a one-page summary using the existing template idea.",
      "There is clear messaging encouraging review with a trusted adult before sharing."
    ]
  },
  {
    "sequence": 20,
    "id": "WS-CODEX-020",
    "phase": "Phase 6\u20138 \u2013 Replay, polish, and release",
    "title": "Implement Replay Station (Time Tunnels) and v1 polish (accessibility, performance, docs)",
    "summary": "Build the Replay Station to revisit snapshots, then address accessibility, performance, and finalize documentation for v1.",
    "instructions": "You are implementing the Replay Station: Time Tunnels, and finishing v1 polish.\n\nGoal for this task:\nAllow children to revisit earlier project snapshots safely, and then bring the app to a v1-ready state with accessibility, performance, and documentation updates.\n\nPerform these steps:\n\n1) Extend Project type with snapshot support\n   - In app/src/domain/project.ts, add a snapshots slice such as:\n     - snapshots?: {\n         id: string;\n         createdAt: string;\n         label: string;\n         projectState: Partial<Project>;\n       }[];\n   - Keep this bounded (for example max 10 snapshots per project).\n\n2) Add snapshot creation logic\n   - Decide where snapshots are created (for example after significant milestones or manually from Memory/Reflect/Share).\n   - Implement helper functions to createSnapshot(project) and prune old snapshots.\n   - Ensure projectState does not include unnecessary bulky data; keep it compact.\n\n3) Create ReplayStationPage component\n   - In app/src/stations/replay/ReplayStationPage.tsx:\n     - Use useProjects() to get the selected project.\n     - Display a simple vertical or horizontal list of snapshots with timestamps and labels.\n     - Allow the child to:\n       - Inspect a snapshot (show read-only view of key fields).\n       - Create a new branch from a snapshot by:\n         - Copying snapshot.projectState into a new Project or overwriting the current one, only after explicit confirmation.\n     - Provide very clear confirmation text before overwriting any current state.\n\n4) Boundaries and safety\n   - Limit the number of snapshots and make sure snapshot create/restore actions are deliberate.\n   - Avoid language that suggests regret; frame Replay as exploring alternate paths and learning from earlier points.\n\n5) Accessibility and performance pass\n   - Review the app UI for:\n     - Keyboard navigation across major controls and stations.\n     - Sufficient color contrast and font sizes for children.\n     - ARIA labels on primary interactive elements where needed.\n   - Test performance on low and mid-range devices:\n     - Confirm WebLLM model loads reasonably.\n     - Adjust model choice or configuration if needed for responsiveness.\n\n6) Documentation and v1 tagging\n   - Update or create:\n     - docs/PROJECT_PLAN_FULL.md (if needed) with actual status notes.\n     - roadmap/MASTER_TIMELINE.md with actual sprint outcomes or tweaks.\n     - Any station-specific docs that have diverged during implementation.\n   - Prepare a short RELEASE_NOTES.md for v1 describing the feature set.\n   - Ensure package.json version is set to 1.0.0 or similar.\n\nThis is a capstone task: after completing it, The Workshop should be in a coherent, shippable v1 state.",
    "acceptance_criteria": [
      "Project type has a bounded snapshots slice for Replay.",
      "ReplayStationPage.tsx exists and lets users inspect snapshots and create branches or restore with clear confirmation steps.",
      "Snapshot creation and pruning helpers are in place and keep snapshot data compact.",
      "An accessibility and basic performance pass has been made, with obvious issues addressed.",
      "Key docs (project plan, timeline, station specs) are updated to reflect the implemented v1, and release notes exist."
    ]
  }
]