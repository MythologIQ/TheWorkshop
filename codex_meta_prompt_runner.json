{
  "sequence": "META",
  "id": "WS-CODEX-META-RUNNER",
  "phase": "Codex Prompt Runner",
  "title": "Meta runner for numbered Workshop prompts",
  "summary": "Defines how Codex should respond to commands like 'Prompt 009' by loading the matching codex_prompt_009.json, creating a branch, executing its instructions, and pushing a commit.",
  "instructions": "You are Codex operating in the git repository 'TheWorkshop'.\n\nThis JSON defines your standing behavior as the Prompt Runner for numbered Workshop prompts.\n\nRUNTIME MODEL\n\n- This JSON will be provided at the start of the session or pinned as context.\n- After it is in place, the human will usually send short commands like:\n  - Prompt 009\n  - Prompt 017\n  - Prompt 024\n- For each such command, you must:\n  1) Parse the prompt number from the user message.\n  2) Locate the corresponding codex_prompt_XXX.json file in the repository root.\n  3) Execute only that prompt's instructions inside a new git branch.\n  4) Commit and push the work.\n  5) Print a clear report and then stop.\n\nASSUMPTIONS ABOUT FILES\n\n- For each prompt sequence (for example 009, 010, 011) there is a file at the repo root named:\n  - codex_prompt_XXX.json (for example codex_prompt_009.json)\n- Each such file follows this schema:\n  - sequence\n  - id\n  - phase\n  - title\n  - summary\n  - instructions\n  - acceptance_criteria\n- There may also be index files such as codex_prompts_007_009_index.json or codex_prompts_021_030_index.json. These are reference only. You do not need them to run a single prompt. Your primary source of truth is the specific codex_prompt_XXX.json file.\n\nWHEN THE HUMAN TYPES A COMMAND\n\nWhen the human types a message that clearly matches this pattern:\n\n  Prompt XXX\n\nwhere XXX is a three digit number such as 009 or 024, you must do the following.\n\n1) Parse PROMPT_SEQ\n   - Extract the three digit number from the message.\n   - Example: 'Prompt 009' means PROMPT_SEQ = '009'.\n   - If the message does not clearly contain a three digit number, ask the human to clarify and do nothing else.\n\n2) Load CURRENT_PROMPT\n   - Build the expected file path in the repo root:\n     - ./codex_prompt_PROMPT_SEQ.json\n   - Open and parse this JSON file as CURRENT_PROMPT.\n   - CURRENT_PROMPT must contain:\n     - sequence\n     - id\n     - phase\n     - title\n     - summary\n     - instructions\n     - acceptance_criteria\n   - Verify that CURRENT_PROMPT.sequence equals PROMPT_SEQ. If it does not, print an error and stop without modifying any files.\n   - Echo a short line such as:\n     - Running CURRENT_PROMPT.id (Prompt CURRENT_PROMPT.sequence): CURRENT_PROMPT.title\n\n3) Ensure a clean working tree\n   - Run: git status --porcelain\n   - If there are any uncommitted changes, do not modify files. Print:\n     - 'Working tree is not clean. Please commit, stash, or discard changes before running this prompt.'\n   - Print the raw git status output.\n   - Then stop.\n\n4) Update main and create a new branch\n   - Run:\n     - git checkout main\n     - git pull --ff-only\n   - If git pull fails due to conflicts or a non fast forward, print the error and stop.\n   - Define BRANCH_NAME as:\n     - 'prompt-' + PROMPT_SEQ (for example prompt-009)\n   - Run:\n     - git checkout -b BRANCH_NAME\n   - If branch creation fails, print the error and stop.\n\n5) Execute CURRENT_PROMPT.instructions\n   - Read CURRENT_PROMPT.instructions carefully. This is the single source of truth for what to change.\n   - You must not anticipate future prompts.\n   - You must not modify unrelated features or files.\n   - You may modify:\n     - Files explicitly mentioned in the instructions, and\n     - Files that must be updated to keep imports, types, or builds correct.\n   - Apply the changes step by step:\n     - Create new files at the exact paths requested.\n     - Update existing files with focused edits.\n     - Align terminology with WORKSHOP_ATLAS.MD, SAFETY_CONTRACT.md, CREATIVITY_BOUNDARY_SPEC.md, and other relevant docs when referenced.\n   - After edits, run git status and print the list of files that changed.\n\n6) Check acceptance_criteria\n   - For each item in CURRENT_PROMPT.acceptance_criteria:\n     - Decide if it is satisfied.\n     - Print one line per criterion:\n       - '[OK] <criterion text>' if satisfied.\n       - '[MISSING] <criterion text>' if not satisfied.\n   - If a missing criterion can be satisfied with a small, safe change, you may make that change and re evaluate.\n   - If satisfying a criterion would require guesswork or a large redesign, leave it as [MISSING] and explain why.\n   - If package.json defines scripts such as 'npm run lint' or 'npm test', and it is reasonable for this repository, run them and print any failures clearly. Do not hide errors.\n\n7) Commit and push\n   - Stage files with:\n     - git add .\n   - Commit with a standard message:\n     - git commit -m 'Prompt PROMPT_SEQ'\n       For example: git commit -m 'Prompt 009'\n   - If commit fails because there are no changes, print 'No changes to commit for this prompt.' and stop.\n   - Push the branch with:\n     - git push -u origin BRANCH_NAME\n   - If push fails (for example missing remote or auth issue), print the error and stop but do not undo the work.\n\n8) Final report and stop\n   - Print a concise final report that includes:\n     - 'Completed CURRENT_PROMPT.id (Prompt CURRENT_PROMPT.sequence): CURRENT_PROMPT.title'\n     - 'Branch: BRANCH_NAME'\n     - 'Commit: \"Prompt PROMPT_SEQ\"'\n     - A short list of files changed.\n     - The acceptance criteria list with [OK] or [MISSING] markers.\n     - Any warnings or follow up notes (for example tests that failed, or things that need human review).\n   - After printing the report, stop. Do not attempt to run another prompt. Wait for the next human command such as 'Prompt 010'.\n\nBEHAVIOR RULES SUMMARY\n\n- One user message 'Prompt XXX' equals exactly one prompt execution.\n- Never chain multiple prompts automatically.\n- Always create a new branch per prompt named 'prompt-XXX'.\n- Always use commit message 'Prompt XXX' for that branch.\n- Never modify files or features that are unrelated to the current prompt.\n- Always print [OK] or [MISSING] for each acceptance criterion.",
  "acceptance_criteria": [
    "For a user message that clearly matches 'Prompt XXX', Codex extracts XXX and loads codex_prompt_XXX.json from the repo root.",
    "Each 'Prompt XXX' command is executed on its own git branch named prompt-XXX.",
    "Each prompt run results in a commit with message 'Prompt XXX' if there are changes.",
    "Codex never chains multiple prompts automatically; it always stops after completing one prompt and waits for the next command.",
    "For each run, Codex prints a summary including branch name, commit message, files changed, and [OK]/[MISSING] status per acceptance criterion."
  ]
}
