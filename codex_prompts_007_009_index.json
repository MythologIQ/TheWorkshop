[
  {
    "sequence": "007",
    "id": "WS-CODEX-007",
    "phase": "Scaffolding Bridge: Data Model Integration",
    "title": "Implement Project Persistence Layer and Local Storage Adapter",
    "summary": "Replace placeholder projectStore with a full domain model, storage adapter, autosave, and alignment to Workshop ATLAS terminology.",
    "instructions": "You must follow the WORKSHOP_ATLAS.MD terminology and the SAFETY_CONTRACT.md rules.\n\nGoal for this task:\nImplement a real domain shape and persistence layer so that projects, steps, reflections, and tests survive reloads and can be safely extended by later stations.\n\nPerform these steps:\n\n1) Create domain folder and types\n   - Create a folder: app/src/domain/\n   - Add TypeScript models:\n     - project.ts\n     - step.ts\n     - reflection.ts\n     - test.ts\n     - archive.ts\n   - Define interfaces for:\n     - Project\n     - Goal\n     - Step\n     - Reflection\n     - TestResult\n     - ArchiveEntry\n   - Keep these types small and focused, with comments that reference the Workshop ATLAS concepts (Idea Station, Build Station, etc).\n\n2) Implement ID helper\n   - Add a small helper (for example in app/src/domain/id.ts) that wraps nanoid or a similar tiny ID generator.\n   - Use this helper for all new Project, Step, Reflection, TestResult, and ArchiveEntry IDs.\n\n3) Implement local storage adapter\n   - Create app/src/runtime/storage/local_storage_adapter.ts.\n   - Implement functions:\n     - saveProject(project: Project): Promise<void>\n     - loadProject(id: string): Promise<Project | null>\n     - listProjects(): Promise<Project[]>\n     - deleteProject(id: string): Promise<void>\n   - Use window.localStorage under a single key namespace like \"workshop.projects\".\n   - Handle missing or malformed data defensively: never throw, always repair or return safe defaults.\n\n4) Wire projectStore to the adapter\n   - Update or create projectStore so it no longer holds a purely in-memory map.\n   - On initialization, call listProjects() to populate state.\n   - When creating, updating, or deleting projects, always call the adapter.\n   - Ensure that the active project ID is saved (for example under \"workshop.activeProjectId\") so it can be restored on reload.\n\n5) Autosave behavior\n   - Ensure that whenever a Step, Reflection, or TestResult is updated, the owning Project is saved.\n   - Keep autosave behavior simple and predictable; you may debounce writes lightly, but do not use complex queues for v1.\n\nRespect the Creativity Boundary spec:\n   - Before saving, clamp text lengths and counts to the limits described there.\n   - Document truncation behavior with comments so it is easy to reason about later.\n\nDo not design station UIs in this task. Focus only on domain types, the adapter, and projectStore wiring.",
    "acceptance_criteria": [
      "app/src/domain/ defines Project, Goal, Step, Reflection, TestResult, and ArchiveEntry types aligned with Workshop ATLAS terminology.",
      "An ID helper exists and is used for new entities.",
      "local_storage_adapter.ts implements saveProject, loadProject, listProjects, and deleteProject using localStorage safely.",
      "projectStore initialization and mutation paths now depend on the adapter rather than in-memory-only state.",
      "Active project ID is persisted and restored, and autosave persists edits to steps, reflections, and tests."
    ]
  },
  {
    "sequence": "008",
    "id": "WS-CODEX-008",
    "phase": "UI Bridge: Layout and Navigation",
    "title": "Implement Global Layout, Station Chrome, and Navigation Shell",
    "summary": "Replace placeholder UI with real Workshop chroming, station-aware navigation, and a responsive shell that wraps all stations.",
    "instructions": "You must follow the design language and metaphors in WORKSHOP_ATLAS.MD (starship shipyard, Stations, calm workshop feel).\n\nGoal for this task:\nBuild the global layout, navigation shell, and Station chrome so that all Stations live inside a consistent, kid-friendly interface.\n\nPerform these steps:\n\n1) Layout components\n   - Create a folder: app/src/ui/layout/\n   - Implement components:\n     - ShellLayout.tsx: top-level frame with header, side navigation, and content area.\n     - StationNav.tsx: vertical or horizontal navigation showing all Stations.\n     - TopBar.tsx: shows current project name, active Station, and a simple status area.\n     - BackgroundCanvas.tsx: optional background layer that can render the hangar/starfield visual.\n\n2) Station navigation\n   - StationNav must show entries (with icons if available) for:\n     - Idea (Design Dock)\n     - Build (Assembly Bay)\n     - Test (Diagnostics Corridor)\n     - Memory (Stellar Archive)\n     - Reflect (Orbiter Bridge)\n     - Share (Broadcast Deck)\n     - Replay (Time Tunnels)\n   - Use a shared station registry (for example app/src/domain/stations.ts) so routes, labels, and icons all come from the same source.\n   - Make sure the navigation is accessible: focusable, screen-reader friendly, and clearly highlights the active station.\n\n3) Routing integration\n   - Connect StationNav to the router:\n     - Each Station should have a route such as /station/idea, /station/build, etc.\n     - Clicking a nav item updates both the URL and the current activeStation in uiStore (or equivalent).\n   - Ensure that when the app loads without a project selected, the shell either:\n     - Redirects to the ProjectSelectionPage, or\n     - Shows a gentle gate message and a button to choose a project.\n\n4) Visual style\n   - Use Tailwind and Radix/Shadcn components where they exist.\n   - Match the Workshop themes:\n     - Calm blues and violets, soft shapes, generous padding.\n     - Clear hierarchy: Stations on the side, content center, global header on top.\n   - Make sure the layout responds sensibly to smaller viewports.\n\n5) Remove placeholder screens\n   - Replace any placeholder 'Coming soon' divs or bare text with the real layout components, even if the inner Station content is still minimal.\n   - Keep Station pages as distinct components that are rendered inside ShellLayout.\n\nDo not implement deep Station logic here. Focus on the shell, navigation, and a coherent look and feel.",
    "acceptance_criteria": [
      "ShellLayout, StationNav, TopBar, and (optional) BackgroundCanvas components exist under app/src/ui/layout/.",
      "All Stations are listed in a central registry and rendered in StationNav with correct labels and icons (where assets exist).",
      "Router and uiStore remain in sync for the active Station and routes like /station/idea work.",
      "The app uses a consistent visual shell aligned with Workshop themes, with no placeholder-only pages remaining.",
      "The layout behaves reasonably on smaller screens and exposes keyboard-focusable navigation."
    ]
  },
  {
    "sequence": "009",
    "id": "WS-CODEX-009",
    "phase": "AI Runtime Bridge",
    "title": "Replace AIProvider Mock with WebLLM-Powered Streaming Engine",
    "summary": "Wire the AIProvider to the real WebLLM engine, inject Safety Contract and Creativity Boundaries, and expose a clean station-aware streaming API.",
    "instructions": "You must respect the SAFETY_CONTRACT.md and docs/CREATIVITY_BOUNDARY_SPEC.md in every AI call.\n\nGoal for this task:\nRemove the AIProvider mock/stub and connect the UI to the real WebLLM runtime via a station-aware streaming API.\n\nPerform these steps:\n\n1) Locate AIProvider\n   - Find the AIProvider implementation (for example app/src/runtime/ai/AIProvider.tsx).\n   - If it does not exist yet, create it in a sensible location under app/src/runtime/ai/.\n\n2) Replace mock logic\n   - Remove any string-splitting or fake streaming behavior.\n   - Import generateStream(prompt: string) from webllm_loader.ts (implemented in WS-CODEX-010).\n\n3) Define AIProvider context shape\n   - The context should expose at least:\n     - streamStationCall(stationKey: string, payload: { systemPrompt: string; userPrompt: string }): AsyncGenerator<{ token: string; done: boolean }>\n   - Optionally also expose:\n     - lastError, lastStationKey, isStreaming flags.\n\n4) Inject Safety Contract and Creativity Boundaries\n   - Create a helper (for example app/src/runtime/ai/prompt_builder.ts) that:\n     - Loads or inlines the key rules from SAFETY_CONTRACT.md.\n     - Loads or inlines the key constraints from CREATIVITY_BOUNDARY_SPEC.md.\n     - Combines them with the station-specific systemPrompt and the userPrompt into a single finalPrompt string.\n   - Ensure the finalPrompt is clearly structured and commented for future maintenance.\n\n5) Station-aware calling\n   - streamStationCall should:\n     - Accept a stationKey like 'idea', 'build', 'test', 'memory', 'reflect', 'share', or 'replay'.\n     - Use prompt_builder to construct finalPrompt with station name and rules.\n     - Call generateStream(finalPrompt) and return its async generator.\n\n6) Token and time limits\n   - Add a simple layer that:\n     - Enforces a maximum token budget per call (documented in comments).\n     - Enforces a reasonable timeout for a request; if exceeded, surface a friendly error.\n\n7) React hook\n   - Implement a useAI() hook that returns the AIProvider context.\n   - Guard against usage outside the provider with a clear error message.\n\nDo not design each station systemPrompt here beyond basic placeholders; detailed station prompt content can be refined in later tasks. Focus on plumbing, safety enforcement, and streaming behavior.",
    "acceptance_criteria": [
      "AIProvider no longer uses any mock or stubbed LLM behavior.",
      "streamStationCall(stationKey, payload) exists and delegates to generateStream via a structured finalPrompt.",
      "Safety Contract rules and Creativity Boundary constraints are injected into every AI call via a prompt builder helper.",
      "A useAI() hook is available and returns the provider context, with proper error handling outside the provider.",
      "Token and timeout limits are implemented and documented, and streaming works for at least one Station in the UI."
    ]
  }
]